package secret_test

import (
	"bytes"
	"context"
	"encoding/base64"
	"strings"
	"testing"
	"time"

	"github.com/imdario/mergo"
	"github.com/spf13/viper"
	"github.com/stretchr/testify/require"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"

	"github.com/mittwald/kubernetes-secret-generator/pkg/controller/secret"
)

func newStringTestSecret(fields string, extraAnnotations map[string]string, initValues string) *corev1.Secret {
	annotations := map[string]string{
		secret.AnnotationSecretAutoGenerate: fields,
	}
	if extraAnnotations != nil {
		if err := mergo.Merge(&annotations, extraAnnotations, mergo.WithOverride); err != nil {
			panic(err)
		}
	}

	s := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      getSecretName(),
			Namespace: "default",
			Labels: map[string]string{
				labelSecretGeneratorTest: "yes",
			},
			Annotations: annotations,
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{},
	}

	keys := strings.Split(fields, ",")
	for i, init := range strings.Split(initValues, ",") {
		s.Data[keys[i]] = []byte(init)
	}

	return s
}

// verify basic fields of the secret are present
func verifyStringSecret(t *testing.T, in, out *corev1.Secret, secure bool) {
	if out.Annotations[secret.AnnotationSecretType] != string(secret.TypeString) {
		t.Errorf("generated secret has wrong type %s on  %s annotation", out.Annotations[secret.AnnotationSecretType], secret.AnnotationSecretType)
	}

	if out.Annotations[secret.AnnotationSecretSecure] != "yes" && secure {
		t.Errorf("generated secret has no %s annotation", secret.AnnotationSecretSecure)
	} else if out.Annotations[secret.AnnotationSecretSecure] == "yes" && !secure {
		t.Errorf("generated secret has %s annotation", secret.AnnotationSecretSecure)
	}

	_, wasGenerated := in.Annotations[secret.AnnotationSecretAutoGeneratedAt]

	for _, key := range strings.Split(in.Annotations[secret.AnnotationSecretAutoGenerate], ",") {
		val, ok := out.Data[key]
		if !ok {
			t.Error("secret value has not been generated")
		}

		// check if secret has correct length (if the secret has actually been generated)
		if !wasGenerated && (len(val) == 0 || len(val) != desiredLength(in)) {
			t.Errorf("generated field has wrong length of %d", len(val))
		}

		t.Logf("generated secret value: %s", val)
	}

	if _, ok := out.Annotations[secret.AnnotationSecretAutoGeneratedAt]; !ok {
		t.Errorf("secret has no %s annotation", secret.AnnotationSecretAutoGeneratedAt)
	}
}

func desiredLength(s *corev1.Secret) int {
	length, err := secret.GetLengthFromAnnotation(secret.DefaultLength(), s.Annotations)
	if err != nil {
		return secret.DefaultLength()
	}
	parsed, _, _ := secret.ParseByteLength(secret.DefaultLength(), length)

	return parsed
}

// verify requested keys have been regenerated
func verifyStringRegen(t *testing.T, in, out *corev1.Secret) {
	if _, ok := out.Annotations[secret.AnnotationSecretRegenerate]; ok {
		t.Errorf("%s annotation is still present", secret.AnnotationSecretRegenerate)
	}

	if _, ok := in.Annotations[secret.AnnotationSecretRegenerate]; !ok && !secret.RegenerateInsecure() { // test the tester
		t.Errorf("%s annotation is not present on input", secret.AnnotationSecretRegenerate)
	}

	if _, ok := in.Annotations[secret.AnnotationSecretAutoGeneratedAt]; !ok { // test the tester
		t.Errorf("%s annotation is not present on input", secret.AnnotationSecretAutoGeneratedAt)
	}

	var regenKeys []string
	if in.Annotations[secret.AnnotationSecretRegenerate] == "yes" ||
		secret.RegenerateInsecure() && in.Annotations[secret.AnnotationSecretSecure] == "" {
		regenKeys = strings.Split(in.Annotations[secret.AnnotationSecretAutoGenerate], ",")
	} else if in.Annotations[secret.AnnotationSecretRegenerate] != "" {
		regenKeys = strings.Split(in.Annotations[secret.AnnotationSecretRegenerate], ",")
	}

	t.Logf("checking regenerated keys are regenerated and have correct length")
	t.Logf("keys expected to be regenerated: %d", len(regenKeys))
	if len(regenKeys) != 0 {
		for _, key := range regenKeys {
			val := out.Data[key]
			if len(val) == 0 || len(val) != secret.DefaultLength() {
				// check length here again, verifyStringSecret skips this for secrets that already had the generatedAt Annotation
				t.Errorf("regenerated field has wrong length of %d", len(val))
			}

			if bytes.Equal(in.Data[key], val) {
				t.Errorf("key %s is equal for in(%s) and out (%s)", key, in.Data[key], out.Data[key])
				continue
			}
			t.Logf("key %s is NOT equal for in(%s) and out (%s)", key, in.Data[key], out.Data[key])
		}
	}

	t.Logf("checking generated keys are not regenerated")
	genKeys := strings.Split(in.Annotations[secret.AnnotationSecretAutoGenerate], ",")
	for _, key := range genKeys {
		if stringInSlice(key, regenKeys) {
			continue
		}
		if bytes.Equal(in.Data[key], out.Data[key]) {
			t.Logf("key %s is equal for in(%s) and out (%s)", key, in.Data[key], out.Data[key])
			continue
		}
		t.Errorf("key %s is NOT equal for in(%s) and out (%s)", key, in.Data[key], out.Data[key])
	}
}

func TestGenerateSecretSingleField(t *testing.T) {
	in := newStringTestSecret("testfield", nil, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
}

func TestGenerateSecretMultipleFields(t *testing.T) {
	in := newStringTestSecret("testfield,test1,test2,test3,abc,12345,6789", nil, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
}

func TestRegenerateSingleField(t *testing.T) {
	in := newStringTestSecret("testfield", map[string]string{
		secret.AnnotationSecretRegenerate:      "testfield",
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "test")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	verifyStringRegen(t, in, out)
}

func TestRegenerateAllSingleField(t *testing.T) {
	in := newStringTestSecret("testfield", map[string]string{
		secret.AnnotationSecretRegenerate:      "yes",
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "test")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	verifyStringRegen(t, in, out)
}

func TestRegenerateMultipleFieldsSecure(t *testing.T) {
	in := newStringTestSecret("testfield,test1,test2", map[string]string{
		secret.AnnotationSecretRegenerate:      "testfield",
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
		secret.AnnotationSecretSecure:          "yes",
	}, "test,abc,def")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	verifyStringRegen(t, in, out)
}

func TestRegenerateMultipleFieldsNotSecure(t *testing.T) {
	in := newStringTestSecret("testfield,test1,test2", map[string]string{
		secret.AnnotationSecretRegenerate:      "testfield",
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "test,abc,def")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, false)
	verifyStringRegen(t, in, out)
}

func TestRegenerateAllMultipleFields(t *testing.T) {
	in := newStringTestSecret("testfield,test1,test2", map[string]string{
		secret.AnnotationSecretRegenerate:      "yes",
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "test,abc,def")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	verifyStringRegen(t, in, out)
}

func TestRegenerateInsecureSingleField(t *testing.T) {
	viper.Set("regenerate-insecure", true)
	in := newStringTestSecret("testfield", map[string]string{
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "test")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	verifyStringRegen(t, in, out)
	viper.Set("regenerate-insecure", false)
}

func TestRegenerateInsecureEmpty(t *testing.T) {
	viper.Set("regenerate-insecure", true)
	in := newStringTestSecret("testfield", nil, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	viper.Set("regenerate-insecure", false)
}

func TestRegenerateInsecureSingleFieldSecureBefore(t *testing.T) {
	viper.Set("regenerate-insecure", true)
	in := newStringTestSecret("testfield", map[string]string{
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
		secret.AnnotationSecretSecure:          "yes",
	}, "test")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	verifyStringRegen(t, in, out)
	viper.Set("regenerate-insecure", false)
}

func TestRegenerateInsecureMultipleField(t *testing.T) {
	viper.Set("regenerate-insecure", true)
	in := newStringTestSecret("testfield,test1,test2,test3", map[string]string{
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
	}, "abc,def,ghi,jkl")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	verifyStringRegen(t, in, out)
	viper.Set("regenerate-insecure", false)
}

func TestRegenerateInsecureMultipleFieldSecureBefore(t *testing.T) {
	viper.Set("regenerate-insecure", true)
	in := newStringTestSecret("testfield,test1,test2,test3", map[string]string{
		secret.AnnotationSecretAutoGeneratedAt: time.Now().Format(time.RFC3339),
		secret.AnnotationSecretSecure:          "yes",
	}, "abc,def,ghi,jkl")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))

	verifyStringSecret(t, in, out, true)
	verifyStringRegen(t, in, out)
	viper.Set("regenerate-insecure", false)
}

func TestUniqueness(t *testing.T) {
	in := newStringTestSecret("testfield,abc,test,abc,oops,oops", nil, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, true)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
}

func TestDefaultToStringGeneration(t *testing.T) {
	in := newStringTestSecret("testfield", nil, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifyStringSecret(t, in, out, true)
}

func TestTemplateFromAnnotation(t *testing.T) {
	in := newStringTestSecret("testfield", map[string]string{
		secret.AnnotationSecretType:     string(secret.TypeString),
		secret.AnnotationSecretTemplate: `{"username": "user", "password": "${SECRET}"}`,
	}, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	const prefix = `{"username": "user", "password": "`
	const suffix = `"}`
	if !bytes.HasPrefix(out.Data["testfield"], []byte(prefix)) || bytes.HasSuffix(out.Data["testfield"], []byte(suffix)) {
		t.Errorf("Generated secret did not match template prefix/suffix: %s", string(out.Data["testfield"]))
	}

	secret := bytes.TrimSuffix(bytes.TrimPrefix(out.Data["testfield"], []byte(prefix)), []byte(suffix))

	t.Log(string(secret))
}

func TestStringTypeAnnotationDetected(t *testing.T) {
	in := newStringTestSecret("testfield", map[string]string{
		secret.AnnotationSecretType: string(secret.TypeString),
	}, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifyStringSecret(t, in, out, true)
}

func TestStringLengthFromAnnotation(t *testing.T) {
	in := newStringTestSecret("testfield", map[string]string{
		secret.AnnotationSecretType:   string(secret.TypeString),
		secret.AnnotationSecretLength: "42",
	}, "")
	require.NoError(t, mgr.GetClient().Create(context.TODO(), in))

	doReconcile(t, in, false)

	out := &corev1.Secret{}
	require.NoError(t, mgr.GetClient().Get(context.TODO(), types.NamespacedName{
		Name:      in.Name,
		Namespace: in.Namespace}, out))
	verifyStringSecret(t, in, out, true)
	if len(out.Data["testfield"]) != 42 {
		t.Error("mismatch between secret length and annotation")
	}
}

func TestGeneratedSecretsHaveCorrectLength(t *testing.T) {
	pwd, err := secret.GenerateRandomString(20, "base64", false)

	t.Log("generated", pwd)

	if err != nil {
		t.Error(err)
	}

	if len(pwd) != 20 {
		t.Error("string length", "expected", 20, "got", len(pwd))
	}
}

func TestGeneratedSecretsHaveCorrectByteLength(t *testing.T) {
	pwd, err := secret.GenerateRandomString(20, "base64", true)

	t.Log("generated", pwd)

	if err != nil {
		t.Error(err)
	}
	val, err := base64.StdEncoding.DecodeString(string(pwd))
	if err != nil {
		t.Error(err)
	}
	if len(val) != 20 {
		t.Error("string length", "expected", 20, "got", len(pwd))
	}
}

func TestGeneratedSecretsAreRandom(t *testing.T) {
	one, errOne := secret.GenerateRandomString(32, "base64", false)
	two, errTwo := secret.GenerateRandomString(32, "base64", false)

	if errOne != nil {
		t.Error(errOne)
	}
	if errTwo != nil {
		t.Error(errTwo)
	}

	if string(one) == string(two) {
		t.Error("string equality", "got", one)
	}
}

func BenchmarkGenerateSecret(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, err := secret.GenerateRandomString(32, "base64", false)
		if err != nil {
			b.Error(err)
		}
	}
}
